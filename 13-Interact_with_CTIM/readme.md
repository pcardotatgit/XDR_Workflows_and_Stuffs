# Dealing with XDR CTIM ( Cisco Threat Intelligence Model )

In this repository You will find  some python scripts given as examples of interaction with CTIM components.

CTIM is one of the core of XDR. This the Threat Hunting dedicated engine and it's attached storage data structure.

The components described into this article are the following here under. 

- Judgments ( for enrichment from private data or for automated Allow / Blocking Feeds creation )
- Sightings ( Ingest single events from 3rd Party Security Solutions into XDR/SecureX Sightings )
- Incidents ( Create Incidents )
- Relationships ( that link objects together )
- Indicators ( that identifiy category of attacks )
- Bundles ( Incidents and attach Sightings to them )
- Verdicts ( for enrichment )

You have to know that CTIM contains more components not described here. 

We are going to focus here on Incidents, related objects and how to create Incidents within XDR.

The here under use case are based on the CTIM API knowledge presented here :

* [Endpoint Infection XDR Demo](https://github.com/pcardotatgit/webex_for_xdr_part-7_The_final_demo)
* [Automated Threat Detection and Mitigation scenario](https://github.com/pcardotatgit/SecureX_Workflows_and_Stuffs/tree/master/100-SecureX_automation_lab)
* [XDR_create_incident_with_python](https://github.com/pcardotatgit/XDR_create_incident_with_python)
* [Create_an_XDR_Incident_from_Ransomware_Detection](https://github.com/pcardotatgit/Create_an_XDR_Incident_from_Ransomware_Detection)
* [https://github.com/pcardotatgit/Create_an_XDR_incident_from_real_time_Attack_Detection_on_XAMPP_Apache_Web_Server](https://github.com/pcardotatgit/Create_an_XDR_incident_from_real_time_Attack_Detection_on_XAMPP_Apache_Web_Server)
* [clean_XDR_Incidents_based_on_selected_Incident](https://github.com/pcardotatgit/clean_XDR_Incidents_based_on_selected_Incident)
* [clean_XDR_Incidents_based_on_source_value](https://github.com/pcardotatgit/clean_XDR_Incidents_based_on_source_value)

And the idea is for you, before going to these use cases, then start here and understand the CTIM objects we need to manipulate for managing XDR Incidents thru a few python scripts.

## Instructions

Before using the python scripts you must first create a XDR / SecureX API client within your tenant, and you must store its **client_id** and **client_password** 

* either into the **./keys/ctr_api_keys.txt** file located into the **/keys** subfolder ( This global configuration file will be used by every scripts in every subfolders )
* or into the **config.py** scripts of every subfolders that will be read first by the python scripts.

Depending on your region, You have to uncomment the host fqdn. You have to do this either into the **config.py** scripts or into the **./keys/ctr_api_keys.txt** file.


## How can we create Incidents and Sightings within XDR / SecureX ?
### Introduction 

Before going to the details about how we can create **incidents** and **sightings** within XDR, you must start first on understanding the CTIM model ( Cisco Threat Intell Model )

### Cisco Threat Intell Model

XDR / SecureX Threat Hunting and Incident Management rely on an internal data structure which is there as a very fast and efficient backend for supporting Threat Hunting activities.

This data structure has several services which all have APIs. That means that we can have access to these services from outside of XDR / SecureX either for reading data, or for ingesting data into it.

Managing **Incidents** within XDR / SecureX is exactly that. Every components of the Incident Manager has an API and we use several of these APIs for creating **Incidents**.
- To learn more about **Cisco Threat Intell Model** you can to go to the following [ DEVNET Learning Lab ](https://developer.cisco.com/learning/tracks/cisco-xdr/cisco-xdr-advanced/private-intel-threat-feed/xdr-private-intelligence-overview/), which will help you to understand the details of how the CTIM APIs can be used into your Threat Hunting activities.
- And you will naturally want to intensively use CTIM API. Then the [ CTIM API documentation here ](https://github.com/threatgrid/ctim/blob/master/doc/tutorials/modeling-threat-intel-ctim.md) will be very usefull for you.

Once Having understanding the CTIM data structure, you are ready to move forward.

### Create Incidents and Sightings.

In order to create documented incidents into the XDR Incident Manager, we just have to create an **Incident** object first. And second we have to attach to it one or several **Sightings**. 

**Incidents** act as an object containers that gather every details of a specific discovered attack campaign. This is acutally a list of events ( Sightings ), with their timeline , observables and referenced links. 

Everything is grouped, sorted and presented in a maner that accelerate Threat Hunting. This is the goal of the Incident.

**Sightings** are representations of the Security Alerts generated by Security Products deployed into the network. **Sightings** are the Security Events, but not the original alerts in their original formats. Sightings actually are  translations of these original alerts into XDR Alert CTIM Schema. 

That means that **Sightings** in XDR are created from original the Security products raw alerts. **Sightings** are interpretation of these product events, which either sumarize them or which extend them.

An **Incident** is supposed to contain several **Sightings** that can have been created from several separated Security Solutions.
The XDR **Attack Chaining** process is able to link separated Sightings together into the same "attack campaign", which becomes an **Incident**.

What we understand is that these Security Solutions are supposed to create **sightings** into XDR at the same time they detect a threat and generate a native alert for it. This is actually what happens with Security Products integrated within XDR. They all run a dedicated additionnal process which monitors product events directly within the product. And for some of these events, the process uses XDR **Sighting** APIs to create the sighting within XDR. This is the "event to sightings promotion process" which creates **Sightings** for the most impactful Security Events. 

We understand as well something else, which is the capability we have to create **XDR Incidents** from outside of the Security Product, but from the Security Alert Collector. So a good way to ingest Product Security Events into XDR is to create a process which periodically reads Security Product events were they are collected ( like a syslog server ) and then create XDR Incident on the behalf of the Security Product.

The goal of an **Incident** as object containers is to collect and gather all alerts that are related to the same security threat. Gathering these interpreted alerts in one place ( into an **incident** ) helps the Security Team to better understand what happen and react more efficiently.

That means that one part of the process is to create an **Incident** if this one doesn't exist and attach to it every **sightings** that are related to the same threat.

**Sightings** are object containers as well.

**Sightings** are supposed to contain **targets** ( the victim machines ) and **observables** ( all suspicious objects which target victim machine ( **targets** ) ) and the **relationship** that link targets and observables together. Most of the time **Sightings** contains **Indicators** which can be seen as a category of attack.  

Something to  notice regarding objects mentionned above is that they are recommended but not mandatory to create a **sighting**.

When XDR receives any **observable**, then several Threat Hunting operations are automatically triggered. This is the case for enrichment and relation graph calculations.  And this is what help Security Operators to go very fast into Investigations. XDR automatically take a part of the investigation and present results to Security Operators.

Threat Intelligence is automatically done by XDR Threat Response.

**Relationships** are key components of CTIM. They are used at several levels. The **relationship** is a table that exists within the CTIM data structure. **Relationships** are used to attach a **Sighting** to an **Incident**. They are used to link an **Indicator** to a **sighting**. And **Relationships** are used to link an **observable** to a **target**.

If we put all this above together, if we want to use XDR APIs to create an Incident within XDR, then we have to use the following APIs :

- Incident
- Relationships
- Sightings
- Indicators ( optionnal )
- Judgments ( optionnal )

Once again more objects exists into CTIM. But we focus only on the object we need to create XDR **Incidents**.

So, when a product detects a threat and generate an alert, then from the original Security Product alert ( event ), within XDR we have to create one **Sightings per product event**. Every **Sightings** must contain **Observables** and their **targets**. And for every couple of **observable to target**, we have to find the **Relationship** that link the **observable** to the **target**. And we have to create a **relationship** of every **sightings** to an existing **Incident**. If this **Incident** doesn't exist we ha to create it.

The CTIM Incident relationships possible values are the following :

- attributed-to
- based-on
- duplicate-of
- derived-from
- detects
- element-of
- exploits
- indicates
- member-of
- mitigates
- related-to
- sighting-of
- targets
- uses
- variant-of

The value to use depends on the context which link object together. Context is mainly lead by the object nature

Have a look to the following documentation in order to have guidelines on this : [Defined Entity Relationships](https://github.com/threatgrid/ctim/blob/master/doc/defined_relationships.md)

In addition to these values above, at  the **observable** level we find dedicated relationships values which are :

[CTIM observable relation map documentation](https://github.com/threatgrid/ctim/blob/74857ac6ffed206b3dcf01f171feb30e08277191/src/ctim/schemas/common.cljc#L408)

The attack graph is builted upon these relationships. It is a representation of these relationships. 
At the same time the relationships link objects together into XDR.

Once **Sightings** are created, then we can create an **Incident** and attach every **Sigthings** to it thank to a **member of** relationship.

**Sightings** are linked to **Indicators** thanks to a **sighting-of** **relationship**.

We understand that we are supposed to use several APIs calls to create all what is needed to create an Incident and all the attached objects. 

CTIM developpers thought about making life easy for programmers. They thought about creating the **bundle** API.

This API allows programmers to create an Incident with everything inside thanks to only one single API call.

The **bundle API** expect a JSON payload to be sent to the API. This JSON payload must contain all the objects we need to create the Incident.

**How can we invoke the bundle API ?**

We create a "bundle" JSON payload which contains one **incident** and all its details. And then we create several **Sightings** into it .

![](./assets/img/1.png)

Then we add into the JSON payload, **relationships** that link every **sightings** to the **Incident** thanks to a **"member of"** **relationship**.

Into every single **sighting**, we include every **targets** and **observables** extracted from the raw Security Solution Alert. And we create as well **relationships** between all these objects within the **sightings**. These 3 things, **targets**, **observables** and **relationships** are 3 separate keys into the **Sighting** JSON data.

And that's it.

Have a look to the [**SecureX Threat Response CTIM Bundle Builder** page ](https://github.com/CiscoSecurity/tr-05-ctim-bundle-builder) to learn about a python module that simplifies **bundle** creation.

### How to read an Incident and parse all Sightings it contains ?

When we create the **Incident** and all **Sightings** it contains, we assign IDs to all objects, and these IDs will be used within the **relationships**. These IDs are known as **target_ref** for incident ID and **source_ref** for Sighting IDs.

![](./assets/img/2.png)

For reading **sigthings** that belong to an **Incident** we must first retrieve its **target_ref** and search for **relationships** based on this **target_ref** information. Thanks to this, we get the list of all **sightings** that belong to the **Incident** and we can get their **source_ref** IDs. Then, for each **Sighting**, based on its **source_ref** we parse it and extract from it everything which is relevant for additionnal investigation. This is mainly **Targets** and **Observables**

## XDR Feeds and How to add observables into XDR / SecureX public feeds thanks to CTIM ?

For doing this, we have to deal with **Judgment**, **Indicators** and **Feeds** APIs.

![](./assets/img/3.png)

Once again, let's start with some terminology in order to make things clear.

We saw that an **observable** is an IOC ( an entity ) that is contained into **Sightings**. It can be an attacked **target** and/or a suspicious entity. 

Within XDR, the enrichment process is responsible to discover the **observable** reputations ( disposition in the XDR terminology : clean , malicious, suspicious, unknown ). And this entity disposition is stored by XDR into the **judgment** table which is a local storage of current **observables** dispositions for a given period of time.  Okay let's keep this in mind.

Let's talk now about **indicators**, . **Indicators** can be seen as attack categories. They are used to group events into groups of attacks. For example SQL Injection attacks and a XSS Attack on a Web server belong to **Web Attacks**. And then **Web Attacks** would be the **Indicator** for them. **Indicators** names are not statically predefined. We can create these names on the fly as we wish. Cisco Security Products use to used their own predefined **Indicators** name. Using "Well known" names is definitely a good practice if this is possible. **Indicators** are additional way that help us to understand quickly what we face to.

What about **feeds**.  **feeds** are list of observables maintained by XDR that store **observables** of the same type ( ip, domain, url, ect ...). These **feeds** are commonly used to created allow/block lists to deploy into firewalls. But not only, these **feeds** can collect and group **observables** into a central storage for any purposes like reports, investigation or anything else. An XDR **feed** is an object container that has a public URL with no authentication needed ( which makes feeds easy to consume by firewalls ). We can easily create several **feeds** within XDR that can contain an maximum of 10 000 **observables**.  XDR Feeds open the door to a lot of Security Use cases.

So the question becomes how can we add an **observable** to a **feeds** ?

Simple... In order to assign an **observable** to a **feed**, we must create a **judgment** for it and we must link this **judgment** to an **Indicator** thanks to a **relationship** ( so we understand that we have to create this **Indicator** first ). 

And we must link this **Indicator** to the **feed** thanks to another **relationship** ( and we understand that we have to create this **feed** first ).

The type of the **observable** is important at this point because this is what will route the **observable** to the correct **feed**. If you remember, we have within XDR one feed per observable type.

So for every relevant **observable** we want to add into XDR feeds, we have to create a **judgment** that link this **observable** to the matching **Indicator** 

Thanks to these chains of relationships, new observables automatically appears into the matching **feed** ( base on their type ), when a  they are added into **judgments**.

**Pre requisits**  

The condition to be able to use these XDR / SecureX feed Services is that **feeds** , **indicators** and **relationships** must have been created first. And None of these objects are created by default when an XDR /  SecureX tenant is started. We have to create them.

Creating the feeds is the role of the following workflow :

- **0015A-SecureFirewall-BlockObservable-Setup**

You must import it and run it first.

## XDR and SecureX don't create incidents the same way !

Incident managements principles are exactly the same for XDR and SecureX.  But XDR doesn't use the same APIs for creating **Incidents**.

That means that everything described into this article is valid for both platform.  But **Incidents** APIs are differents.

One main reason of that is that XDR take into account **asset priority** and not SecureX. A consequence of this is that the code for creating the Incident is not the same.

This is why we have 2 separated version of the lab simulator. **lab_simulator-001** is dedicated to SecureX demos, and **lab_simulator-002** is dedicated to XDR demos.

## Additional resources

Don't hesitate to have a look to this awesome DEVNET learning lab that digs into Incident creation and bundle details.

[Create an Incident with Workflow for Cisco XDR](https://developer.cisco.com/learning/tracks/cisco-xdr/cisco-xdr-advanced/create-incident-with-workflow/introduction/)