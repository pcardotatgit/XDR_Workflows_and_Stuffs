# Solution achitecture

## Solution components

The key components of this solution are the following :

- A python host wich host the lab simulator
- The Lab simulator
- A SecureX tenant 
- Two SecureX Automation workflows
- An Alert Webex Room
- A Webex Team bot

![](assets/img/15.png)

## The Flask application

The Flask application provides with the user interface. It exposes the portal web page from where to show the endpoint attack.

The Flask application has another role in this solution. It provides with a Bot Logic that receives calls from Webex when the security operator click on a link.

In one hand, the application exposes API endpoints for managing :

- Application Configuration
- Attack simulation
- Webex Team Operator choices and SecureX webhook

![](assets/img/16.png)

In the other hand the Flask application run several functions which are triggered by REST calls received on exposed API Endpoints.  These functions are mostly about interaction with SecureX and Webex.

For code clarity, these functions are not all embeded into the **app.py** main script, but they are located into dedicated python scripts outside the **app.py** scripts but linked with it thanks to **import** statements.

## Checking for new incidents

![](assets/img/17.png)

When the attack is blocked into the endpoint, then an Incidents is created within SecureX with attached incidents.

![](assets/img/19.png)

This part is managed by functions in the **create_incident_and_sightings_with_dynamic_data.py** script, called from **app.py**.

We use the Threat Response **Bundle** API. This API allow us to use one single call in order to create everything at once into SecureX.

What we have to do actually is to create a single JSON payload that contains :

- The new **Incident**
- Several **Sightings**
- For every **Sightings** a **member of** **relationship** which link the **Sighting** to the **Incident**
- In every **Sightings**, **observables** and **targets**
- For every **observables** and **targets**, a **relationship** which is a **connected to** **relationship**

This JSON payload is passed as a POST variable to the REST call we send to SecureX and then automatically Incident and Sightings are created. And SecureX Automatically does enrichement for every observable and draw the Relation Graph.

If you dig into the code ( **create_incident_and_sightings_with_dynamic_data.py** ), you will be able to see that we attach 2 sightings with the incident we create. First we decide the value of the Incident ID. This is the **target_ref** variable. And we do the same for **Sigthings IDs** . This is the **source_ref** variable.

These IDs uniquely identify these objects.

So in the first step, we create an new **Incident** and we include into it the first **Sightings**. And in a second call we send a REST call for the same **Incident ID** but with a New **Sighting**  ( with a new ID ) and a new **relationship** with the same incident.   Then automatically our Incident will contain a New **Sighting**.

**Sightings** are actually representations of the Security Alerts generated by Security Products in the network. **Sightings** APIs are an easy way to ingest these original alerts from these security products, into SecureX and link them to the same Security Incident.

## Extract observables and targets , and then send an alert to Webex Team

Within SecureX we run a workflow named **Check Incidents every 5 minutes.json**. This one check if an new incident appeared since the last poll, and if the answer is yes, it read it and extract all **observables** and **target** from them.

When Incident and Sighthings were created within SecureX, IDs were assigned to them. 

- **target_ref** : identifies Incidents
- **source_ref** : identifies Sigthings

Specifically within **relationships**. 

So for retreiving all **Sightings** that are attached to an incident, we have to retreive all relation ships.

![](assets/img/18.png)

Then for every Sightings, we can extracts **observables** and **targets** from them and create an alert message to be sent to the Webex Team Alert room.

This is exactly what the **Check Incidents every 5 minutes.json** SecureX workflow does.

## Send a Webhook to SecureX when clicking on an IP address to block in Webex Team Alert

The alert message sent into a dedicated Webex Team Room is a very effecient way which guaranties fast reactivity.

The goal with this is to allow the Security Operator to instantly block the bad guys. Just by clicking on a link into the alert message from their smart phone.

![](assets/img/11.png)

In this solution, the Flask application act as a bot logic for Webex. The reason for that is that for sending data ( IP to block ) to the SecureX workflow we want to trigger thanks to a webhook, we must send a POST call. 

And unfortunately url links we can include Webex messages are GET call and not POST calls.

Then our flask application act as a relay application for the Webhook, between Webex and SecureX.

Have a look to the **send_webhook_to_secureX.py** script and the **body_message** variable which is the variable we send to the workflow.

The **webhook_url** will be used by the python function to trigger the correct workflow and the **body_message** variable will be sent as a **body** variable.

Within SecureX, the workflow we trigger will be the **Receive observables from a rest client** workflow.

This workflow is supposed to run when our flask application sends the webhook to SecureX. And this is somethings you can check into the Securex **runs**.

The data sent by the Flask application becomes available for the workflow in the variable browser in the **result body** of the **trigger**.

![](assets/img/20.png)

Next step is standard JSON parsing. Which is done in the workflow by a python activity ( personnal choice ).

All the rest happens within the SecureX workflow. The Malicious IP address is extracted from the webhook call. This is the same for the Webex Room Id an webex Bot token.

The Webex Team Room is just here to confirm to the requester that his operation was executed. The last Webex Message only appears when the malicious ip addresse was succesfuly added to the SecureX Blocking Feed.

## Adding malicious IP address to SecureX blocking feed.

The malicious ip address is automatically added to the appriopriate feed by the **0015B-SecureFirewall-BlockObservable** SecureX Workflow, which is included into the **Receive observables from a rest client** workflow.

![](assets/img/8.png)


#And that's it !

